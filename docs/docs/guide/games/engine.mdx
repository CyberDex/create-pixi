---
sidebar_position: 1
title: Engine
---

## Initializing the Game Engine

To initialize the game engine, you need to create an instance of the GameEngine class and call its init method. This method sets up the PixiJS application, initializes the screen manager, and loads the necessary assets.

```ts
import { GameEngine } from './engine/engine';

const engine = new GameEngine();

(async () => {
    await engine.init({
        background: '#1E1E1E',
        resizeOptions: { minWidth: 768, minHeight: 1024, letterbox: false },
    });
})();
```

## Handling Resizing

The game engine automatically handles resizing of the application. The resize behavior can be customized by passing options to the init method.

```ts
await engine.init({
    resizeOptions: { minWidth: 768, minHeight: 1024, letterbox: false },
});
```

- **minWidth**: The minimum width of the application. If the window width is less than this value, the application will scale down to fit the window, but will report a logical width of this value.
- **minHeight**: The minimum height of the application. If the window height is less than this value, the application will scale down to fit the window, but will report a logical height of this value.
- **letterbox**: If true, the canvas will be letterboxed to maintain the aspect ratio of the application. If false, the canvas will be stretched to fill the window.

## Navigation & Screens

The game engine provides a screen manager that allows you to manage different screens in your game. Each screen is a PixiJS Container that implements the Screen interface.

```ts
import { Container } from 'pixi.js';
import { Screen } from './engine/navigation';

export class GameScreen extends Container implements Screen {
    /** Show the screen */
    show?(): Promise<void>;
    /** Hide the screen */
    hide?(): Promise<void>;
    /** Pause the screen */
    pause?(): Promise<void>;
    /** Resume the screen */
    resume?(): Promise<void>;
    /** Prepare screen, before showing */
    prepare?(): void;
    /** Reset screen, after hidden */
    reset?(): void;
    /** Update the screen, passing delta time/step */
    update?(time: Ticker): void;
    /** Resize the screen */
    resize?(width: number, height: number): void;
    /** Blur the screen */
    blur?(): void;
    /** Focus the screen */
    focus?(): void;
}
```

To show different screens in your game, you can use the `showScreen` method of the Navigation class. This method hides the current screen and presents a new screen.

```ts
import { GameScreen } from './game/screens/game/GameScreen';
import { LoadScreen } from './game/screens/LoadScreen';

await engine.navigation.showScreen(LoadScreen);
await engine.navigation.showScreen(GameScreen);
```

### Popup Screens

You can also show popup screens on top of the current screen. Popup screens are displayed in a separate layer above the main screen.

```ts
import { PauseScreen } from './game/screens/PauseScreen';

await engine.navigation.presentPopup(PauseScreen);
```

equally you can hide the popup screen using the `dismissPopup` method.

```ts
await engine.navigation.dismissPopup();
```

### Asset Loading

Using AssetPack you can define bundles of assets for your game. These bundles can be loaded individually to avoid loading all assets at once.
Typically you would define a bundle for each screen in your game, and load them as needed.

To help with this a screen can implements a `static assetBundles: string[]` property that defines the bundles required for that screen. The engine will automatically load these bundles when the screen is shown.

```ts
export class GameScreen extends Container {
  /** Assets bundles required by this screen */
  public static assetBundles = ["game"];

}
```

## Audio

The game engine includes built-in support for managing background music (bgm) and sound effects (sfx). You can control audio playback using the `bgm` and `sfx` properties of the `GameEngine`.

```ts
// Play background music
engine.bgm.play('background-music.mp3', { volume: 0.5 });

// Play sound effect
engine.sfx.play('explosion.mp3', { volume: 0.8 });
```

### Background Music (bgm)
Handles music background, playing only one audio file in loop at time, and fade/stop the music if a new one is requested. Also provide volume control for music background only, leaving other sounds volumes unchanged.

### Sound Effects (sfx)
Handles short sound special effects, mainly for having its own volume settings. The volume control is only a workaround to make it work only with this type of sound, with a limitation of not controlling volume of currently playing instances - only the new ones will have their volume changed. But because most of sound effects are short sounds, this is generally fine.

### Global Volume
While you can control the volume of each audio type, you can also control the global volume of all audio the exposed global volume functions

```ts
engine.setMasterVolume(0.5);
const volume = engine.getMasterVolume();
```

## Utility Functions

The game engine provides several utility functions for common tasks, such as calculating distances, interpolating values, and generating random numbers.

This is not an exhaustive list, but here are some examples:

```ts
import { getDistance, lerp, clamp } from './engine/utils/maths';
import { randomInt, randomFloat } from './engine/utils/random';

const distance = getDistance(0, 0, 10, 10);
const interpolatedValue = lerp(0, 10, 0.5);
const clampedValue = clamp(15, 0, 10);

const randValue = randomInt(0, 10);
const randFloat = randomFloat(0, 10);
```
